<pre>
  BIP: 75
  Title: Out of Band Address Exchange using Payment Protocol Encryption
  Author: Justin Newton <justin@netki.com>
          Matt David <mgd@mgddev.com>
          Aaron Voisine <voisine@gmail.com>
          James MacWhyte <macwhyte@gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2015-11-20
</pre>

==Abstract==

This BIP is an extension to BIP 70 that provides two enhancements to the existing Payment Protocol.

# It allows the requester (Sender) of a PaymentRequest to voluntarily sign the original request and provide a certificate to allow the payee to know the identity of who they are transacting with. 

# It encrypts the PaymentRequest that is returned, before handing it off to the SSL/TLS layer to prevent man in the middle viewing of the Payment Request details.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and 
"OPTIONAL" in this document are to be interpreted as described in RFC 2119.

==Definitions==
{| class="wikitable"
| Sender    || Entity wishing to transfer value that they control
|-
| Receiver  || Entity receiving a value transfer
|}

==Motivation==

The motivation for defining this extension to the BIP70 Payment Protocol is to allow 2 parties to exchange payment information in a permissioned and encrypted way such that wallet address communication can become a more automated process. Additionally, this extension allows for the requester of a PaymentRequest to supply a certificate and signature in order to facilitate identification for address release. This also allows for automated creation of off blockchain transaction logs that are human readable, containing who you transacted with, in addition to the information that it contains today.

The motivation for this extension to BIP70 is threefold:

# Ensure that the payment details can only be seen by the participants in the transaction, and not by any third party.  

# Enhance the Payment Protocol to allow for store and forward servers in order to allow, for example, mobile wallets to sign and serve Payment Requests.

# Allow a sender of funds the option of sharing their identity with the receiver.  This information could then be used to:

#* Make Bitcoin logs more human readable 
#* Give the user the ability to decide who to release payment details to 
#* Allow an entity such as a political campaign to ensure donors match regulatory and legal requirements 
#* Allow for an open standards based way for regulated financial entities to meet regulatory requirements
#* Automate the active exchange of payment addresses, so static addresses and BIP32 X-Pubs can be avoided to maintain privacy and convenience

In short we wanted to make Bitcoin more human, while at the same time improving transaction privacy.

==Example Use Cases==

1. Address Book

A Bitcoin wallet developer would like to offer the ability to store an "address book" of payees, so users could send multiple payments to known entities without having to request an address every time. Static addresses compromise privacy, and address reuse is considered a security risk. BIP32 X-Pubs allow the generation of unique addresses, but watching an X-Pub chain for each person you wish to receive funds from is too resource-intensive for mobile applications, and there is always a risk of unknowingly sending funds to an X-Pub address after the owner has lost access to the corresponding private key.

With this BIP, Bitcoin wallets could maintain an "address book" that only needs to store each payee's public key. Adding an entry to one's address book could be done by using a Wallet Name, scanning a QR code, sending a URI through a text message or e-mail, or searching a public repository. When the user wishes to make a payment, their wallet would do all the work in the background to communicate with the payee's wallet to receive a unique payment address. If the payee's wallet has been lost, replaced, or destroyed, no communication will be possible, and the sending of funds to a "dead" address is prevented.

2. Individual Permissioned Address Release

A Bitcoin wallet developer would like to allow users to view a potential sending party's identifying information before deciding whether or not to share payment information with them. Currently, BIP70 specifies that the Merchant Server respond to a "pay now" style request with a PaymentRequest, releasing address and X.509 certificate identity information of the potential receiving party.

With this BIP, Bitcoin wallets could prompt a wallet user to release payment information while displaying identity information about the potential sending party via an included certificate. This gives the receiving party more control over who receives their payment and identity information, and could be helpful for businesses that need to follow KYC policies or wallets that want to focus on privacy.

3. Using Store & Forward Servers

A Bitcoin wallet developer would like to use a public Store & Forward service for an asynchronous address exchange. This is a common case for mobile and offline wallets.

With this BIP, returned payment information is encrypted with an ECDH-computed shared key before sending to a Store & Forward service. In this case, a successful attack against a Store & Forward service would not be able to read or modify wallet address or payment information, only delete encrypted messages.

==New Messages==
Updated [/bip-0075/paymentrequest.proto paymentrequest.proto] contains the existing PaymentRequest Protocol Buffer messages as well as the messages newly defined in this BIP.

Note: Public keys from both parties must be known to each other in order to facilitate encrypted communication. Although including both public keys in every message may get redundant, it provides the most flexibility as each message is completely self-contained.

===InvoiceRequest===
The InvoiceRequest message allows a Sender to send information to the Receiver such that the Receiver can create and return a PaymentRequest.

<pre>
message InvoiceRequest {
        required bytes  sender_public_key = 1;
        optional uint64 amount = 2 [default = 0];
        optional string pki_type = 3 [default = "none"];
        optional bytes  pki_data = 4;
        optional string memo = 5;
        optional string notification_url = 6;
        optional bytes  signature = 7;
}
</pre>

{| class="wikitable"
! Field Name !! Description
|-
| sender_public_key     || Sender's EC public key
|-
| amount                || amount is integer-number-of-satoshis (default: 0)
|-
| pki_type              || none / x509+sha256 (default: "none")
|-
| pki_data              || Depends on pki_type
|-
| memo                  || Human-readable description of invoice request for the receiver
|-
| notification_url      || Secure (usually TLS-protected HTTP) location where an [[#EncryptedPaymentRequest|EncryptedPaymentRequest]] (see below) SHOULD be sent when ready
|-
| signature             || PKI-dependent signature
|}

===ProtocolMessageType Enum===
The ProtocolMessageType enum is defined in an extensible way to allow for new message type additions to the Payment Protocol. This enum is used in the newly defined ProtocolMessage and EncryptedProtocolMessage messages to define the serialized message type.
<pre>
enum ProtocolMessageType {
    INVOICE_REQUEST = 0;
    PAYMENT_REQUEST = 1;
    PAYMENT = 2;
    PAYMENT_ACK =  3;
}
</pre>

===ProtocolMessage===
The ProtocolMessage message is an encapsulating wrapper for any Payment Protocol message. It allows two-way, non-encrypted communication of Payment Protocol messages. The message also includes a status code and a status message that is used for error communication so the protocol does not rely on transport-layer error handling.
<pre>
message ProtocolMessage {
    required ProtocolMessageType message_type = 1;
    required bytes serialized_message = 2;
    optional uint64 status_code = 3;
    optional string status_message = 4;
    optional bytes identifier = 5;
}
</pre>

{| class="wikitable"
! Field Name !! Description
|-
|message_type               || Message Type of serialized_message (using enum ProtocolMessageType)
|-
|serialized_message         || Serialized Payment Protocol Message
|-
|status_code                || Payment Protocol Status Code
|-
|status_message             || Human-readable Payment Protocol status message
|-
|identifier                 || Unique key to identify this entire exchange on the server. SHA256 of initial serialized InvoiceRequest SHOULD be used by default
|}

===EncryptedProtocolMessage===
The EncryptedProtocolMessage message is an encapsualting wrapper for any Payment Protocol message. It allows two-way, authenticated and encrypted communication of Payment Protocol messages in order to keep their contents secret. The message also includes a status code and status message that is used for error communication so the protocol does not rely on transport-layer error handling.
<pre>
message EncryptedProtocolMessage {
    required ProtocolMessageType message_type = 1;
    required bytes encrypted_message = 2;
    required bytes receiver_public_key = 3;
    required bytes sender_public_key = 4;
    required uint64 nonce = 5;
    optional bytes signature = 6;
    optional bytes identifier = 7;
    optional uint64 status_code = 8;
    optional string status_message = 9;
}
</pre>
{| class="wikitable"
! Field Name   !!  Description
| message_type          || Message Type of Decrypted encrypted_message
|-
| encrypted_message     || AES-256-GCM Encrypted (as defined in BIP75) Payment Protocol Message
|-
| receiver_public_key   || Receiver's DER-encoded EC Public Key
|-
| sender_public_key     || Sender's DER-encoded EC Public Key
|-
| nonce                 || Microseconds since epoch
|-
| signature             || DER-encoded Signature over the full EncryptedProtocolMessage with EC Key Belonging to Sender / Receiver, respectively
|-
| identifier            || Unique key to identify this entire exchange on the server. SHA256 of initial serialized InvoiceRequest SHOULD be used by default
|-
| status_code           || Payment Protocol Status Code
|-
| status_message        || Human-readable Payment Protocol status message
|}

==Payment Protocol Process with InvoiceRequests==
The full process overview for using InvoiceRequests in the Payment Protocol is defined below. All Payment Protocol messages are to be encapsulated in either a ProtocolMessage or EncryptedProcotolMessage. Once the process begins using EncryptedProtocolMessage messages, all subsequent communications MUST use EncryptedProtocolMessages. All Payment Protocol messages SHOULD be communicated using EncryptedProtocolMessage encapsulating messages with the exception that an InvoiceRequest MAY be communicated using the ProtocolMessage if the receiver's public key is unknown.

See [[Sending_Encrypted_Payment_Protocol_Messages_using_EncryptedProtocolMessages|Sending Encrypted Payment Protocol Messages using EncryptedProtocolMessages]] and [[Validating_and_Decrypting_Payment_Protocol_Messages_using_EncryptedProtocolMessages|Validating and Decrypting Payment Protocol Messages using EncryptedProtocolMessages]] for the process of communicating using encrypted Payment Protocol messages.

TODO: See about adding some info about using ProtocolMessages

# Sender creates InvoiceRequest
# Sender encapsulates InvoiceRequest in (Encrypted)ProtocolMessage
# Sender sends (Encrypted)ProtocolMessage to Receiver
# Receiver retrieves InvoiceRequest from (Encrypted)ProtocolMessage
# Receiver creates PaymentRequest
# Receiver encapsulates PaymentRequest in EncryptedProtocolMessage
# Receiver transmits EncryptedProtocolMessage to Sender
# Sender validates PaymentRequest
# The PaymentRequest is processed according to BIP70, including optional Payment and PaymentACK messages encapsulated in EncryptedProtocolMessage messages.

'''NOTE:''' See section [[#Initial_Public_Key_Retrieval_for_InvoiceRequest_Encryption|Initial Public Key Retrieval for InvoiceRequest Encryption]] below for possible options to retrieve Receiver's public key.
 
<img src="bip-0075/encrypted-invoice-request-process.png" alt="Flow diagram of Encrypted InvoiceRequest">

==Message Interaction Details==

===New Message HTTP Content Types===
When communicated via HTTP, these messages MUST be transmitted via TLS-protected HTTP using the appropriate Content-Type header as defined per message type here:
{| class="wikitable"
! Message Type !! Content Type
|-
| ProtocolMessage                   || application/bitcoin-paymentprotocol-message
|-
| EncryptedProtocolMessage          || application/bitcoin-encrypted-paymentprotocol-message
|}

===Payment Protocol Status Communication===

In the case of an error that causes the Payment Protocol process to be stopped or retried for a transaction, a ProtocolMessage or EncryptedProtocolMessage MUST be sent by the party generating the error. The content of the message must contain the same serialized_message or encrypted_message and identifier (if used) and MUST have the status_code set appropriately. The status_message value SHOULD be set with a human readable explanation of the status code. For example, if in an EncryptedProtocolMessage, the provided hash of the serialized message does not match the contents of the message once decrypted, a general error (100) MUST be returned to prevent oracle attacks.

====Payment Protocol Status Codes====
{| class="wikitable"
! Status Code !! Description
|- 
| 1     || OK
|-
| 100   || General / Unknown Error
|-
| 102   || Authentication Failed
|-
| 102   || Encrypted Message Required
|-
| 200   || Amount Too High
|-
| 201   || Amount Too Low
|-
| 202   || Amount Invalid
|-
| 203   || Payment Does Not Meet PaymentRequest Requirements
|-
| 300   || Certificate Required
|-
| 301   || Certificate Expired
|-
| 302   || Certificate Invalid for Transaction
|-
| 303   || Certificate Revoked
|-
| 304   || Certificate Not Well Rooted
|-
|}

===Communication Errors===

Communications errors MUST be communicated to the party that initiated the communication via the communication layer's existing error messaging faciltiies. In the case of TLS-protected HTTP, this SHOULD be done through standard HTTP Status Code messaging ([https://tools.ietf.org/html/rfc7231 RFC 7231 Section 6]).

==New Process Details==
This BIP extends the Payment Protocol as defined in BIP70.

For the following we assume the Sender already knows the Receiver's public key, and the exchange is being facilitated by a Store & Forward server which requires valid signatures for authentication.

Where used, '''nonce''' MUST be set to a non-repeating number AND MUST be chosen by the encryptor. The current epoch time in microseconds SHOULD be used, unless the creating device doesn't have access to a RTC (in the case of a smart card, for example). The service receiving the message containing the '''nonce''' MAY use whatever method to make sure that the '''nonce''' is never repeated.

===InvoiceRequest Message Creation===
* Create an InvoiceRequest message
* sender_public_key MUST be set to the public key of an EC keypair
* Amount is optional. If the amount is not specified by the InvoiceRequest, the Receiver MAY specify the amount in the returned PaymentRequest. If an amount is specified by the InvoiceRequest and a PaymentRequest cannot be generated for that amount, the InvoiceRequest SHOULD return a PaymentRequest with the status_code and status_message fields set appropriately.
* Memo is optional. This MAY be set to a human readable description of the InvoiceRequest
* Set notification_url to URL that the Receiver will submit completed EncryptedPaymentRequest to
* If NOT including certificate, set pki_type to "none"
* If including certificate:
** Set pki_type to "x509+sha256"
** Set pki_data as it would be set in BIP-0070 (see [https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki#Certificates Certificates]) section)
** Sign InvoiceRequest with signature = "" using the X509 Certificate's private key
** Set signature value to the computed signature

===InvoiceRequest Validation===
* Validate sender_public_key is a valid EC public key 
* Validate notification_url if set, contains characters deemed valid for a URL (avoiding XSS related characters, etc).
* If pki_type is None, InvoiceRequest is VALID
* If pki_type is x509+sha256 and signature is valid for the serialized InvoiceRequest where signature is set to "", InvoiceRequest is VALID

===Sending Encrypted Payment Protocol Messages using EncryptedProtocolMessages===
* Encrypt the serialized Payment Protocol message using AES-256-CBC setup as described in [[#ECDH_Point_Generation_and_AES256_GCM_Mode_Setup|ECDH Point Generation and AES-256 (GCM Mode) Setup]] (see below)
* Create EncryptedProtocolMessage message
* Set encrypted_message to be the encrypted value of the Payment Protocol message
* sender_public_key MUST be set to the public key of the Sender's EC keypair
* receiver_public_key MUST be set to the public key of the Receiver's EC keypair
* nonce MUST be set to the nonce used in the AES-256-CBC encryption operation
* requires_payment_message MAY be set to true if the PaymentRequest requires a Payment message '''TODO: How are we doing this now?'''
* Set identifier to the identifier value received in the originating InvoiceRequest's ProtocolMessage or EncryptedProtocolMessage wrapper message
* Set signature to ""
* Sign the serialized EncryptedProtocolMessage message with the communicating party's EC public key
* Set signature to the result of the signature operation above

'''SIGNATURE NOTE:''' EncryptedProtocolMessage messages are signed with the public keys of the party transmitting the message. This allows a Store & Forward server or other transmission system to prevent spam or other abuses. For those who are privacy conscious and don't want the server to track the interactions between two public keys, the Sender can generate a new public key for each interaction to keep their identity anonymous.

===Validating and Decrypting Payment Protocol Messages using EncryptedProtocolMessages===
* The nonce MUST not be repeated. The service receiving the InvoiceRequest MAY use whatever method to make sure that the nonce is never repeated.
* Decrypt the serialized Payment Protocol message using AES-256-GCM setup as described in [[#ECDH_Point_Generation_and_AES256_GCM_Mode_Setup|ECDH Point Generation and AES-256 (GCM Mode) Setup]] (see below)
* Deserialize the serialized Payment Protocol message

===ECDH Point Generation and AES-256 (GCM Mode) Setup===
'''NOTE''': AES-256-GCM is used because it provides authenticated encryption facilities, thus negating the need for a separate message hash for authentication.
* Generate the '''secret point''' using [https://en.wikipedia.org/wiki/Elliptic_curve_Diffie–Hellman ECDH] using the local entity's private key and the remote entity's public key as inputs.
* Initialize [http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf HMAC_DRBG] 
** Use '''SHA256(secret point's X value)''' for Entropy
** Use the given message's nonce field for Nonce
* Initialize AES-256 in GCM Mode
** Use HMAC_DRBG.GENERATE(32) as the Encryption Key (256 bits)
** Use HMAC_DRBG.GENERATE(16) as the Initialization Vector (IV) (128 bits)

===Initial Public Key Retrieval for InvoiceRequest Encryption===
Initial public key retrieval for InvoiceRequest encryption in EncryptedProtocolMessage can be done in a number of ways including, but not limited to, the following:
* Wallet Name public key asset type resolution - DNSSEC-validated name resolution returns Base64 encoded DER-formatted EC public key via TXT Record [https://www.ietf.org/rfc/rfc5480.txt RFC 5480]
* Key Server lookup - Key Server lookup (similar to PGP's pgp.mit.edu) based on key server identifier (i.e., e-mail address) returns Base64 encoded DER-formatted EC public key [https://www.ietf.org/rfc/rfc5480.txt RFC 5480]
* QR Code - Use of QR-code to encode DER-formatted EC public key [https://www.ietf.org/rfc/rfc5480.txt RFC 5480]
* Address Service Public Key Exposure

==Payment / PaymentACK Messages with a Store & Forward Server==
When a Store & Forward server is in use during the Payment Protocol exchange, a Payment message generated as the result of a PaymentRequest with the '''requires_payment_message''' (TODO: Should add something more generic to the encapsulating messages?) flag set to true MUST be accepted by a Store & Forward server. The accepted Payment message is NOT validated as the Store & Forward server does not have access to encrypted data.

Store & Forward servers MAY accept and/or overwrite Payment messages until an PaymentACK message with matching identifier and valid Receiver signature is received, after which the server MAY reject all further Payment messages matching that identifier. This feature SHOULD be used for updating Payment metadata or replacing invalid transactions with valid ones. Clients SHOULD keep in mind Receivers can broadcast a transaction without returning an ACK. If a payment message needs to be updated, it SHOULD include at least one input referenced in the original transaction to prevent the Receiver from broadcasting both transactions and getting paid twice.

==Public Key & Signature Encoding==
* All EC public keys (sender_public_key, receiver_public_key) included in any message defined in this BIP MUST be DER [ITU.X690.1994] encoded.
* All ECC signatures included in any message defined in this BIP MUST use the SHA-256 hashing algorithm and MUST be DER [ITU.X690.1994] encoded.

==Implementation==
A reference implementation for a Store & Forward server supporting this proposal can be found here: 

[https://github.com/netkicorp/addressimo Addressimo]

A reference client implementation can be found in the InvoiceRequest functional testing for Addressimo here: 

[https://github.com/netkicorp/addressimo/blob/master/functest/functest_bip75.py BIP75 Client Reference Implementation]

==BIP70 Extension==
The following flowchart is borrowed from BIP70 and expanded upon in order to visually describe how this BIP is an extension to BIP70.

<img src="bip-0075/bip70-extension.png" alt="Flowchart explaining how this BIP extends BIP 70">

==Mobile to Mobile Examples==

===EncryptedPayment Required===
The following diagram shows a sample flow in which one mobile client is sending value to a second mobile client with the use of an InvoiceRequest, a Store & Forward server, an EncryptedPaymentRequest (with require_payment_message = true), an EncryptedPayment and an EncryptedPaymentACK. In this case, the Receiver submits the transaction to the Bitcoin network.

<img src="bip-0075/mobile-sf-ir-with-payment.png" alt="EncryptedPayment Required flow diagram">

===EncryptedPayment NOT Required===
The following diagram shows a sample flow in which one mobile client is sending value to a second mobile client with the use of an InvoiceRequest, a Store & Forward server, and an EncryptedPaymentRequest (with require_payment_message = false). In this case, the Sender submits the transaction to the Bitcoin network.

<img src="bip-0075/mobile-sf-ir-without-payment.png" alt="EncryptedPayment NOT Required flow diagram">

===Using EncryptedInvoiceRequest Message===
The following diagram shows a sample flow in which one mobile client is sending value to a second mobile client with the use of an EncryptedInvoiceRequest, a Store & Forward server, and an EncryptedPaymentRequest (with require_payment_message = false). In this case, the Sender submits the transaction to the Bitcoin network.

<img src="bip-0075/mobile-sf-encrypted-ir-without-payment.png" alt="EncryptedInvoiceRequest without payment">

==References==

* [[bip-0070.mediawiki|BIP70 - Payment Protocol]]
* [https://en.wikipedia.org/wiki/Elliptic_curve_Diffie–Hellman ECDH]
* [http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf HMAC_DRBG]
* [https://tools.ietf.org/html/rfc6979 RFC6979]
* [https://en.bitcoin.it/wiki/Address_reuse Address Reuse]
* [http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf FIPS 180-4 (Secure Hash Standard)]
